@startuml auth
participant "Apps" as app
participant "ms-investment" as mi
participant "ms-investment-auth" as auth
collections "redis-investment-auth" as dbauth
participant "Common Service" as cs
participant "Additiv\nDFS" as dfs
participant "Additiv\nIdentity Server" as ids

activate app
app -> mi: query risk profile
activate mi
mi -> auth: GET /tokens
activate auth

auth -> dbauth: query session by cif
activate dbauth
dbauth --> auth: return session
note right
{
    sessionId
    accessToken
    expiredAt
}
end note
deactivate dbauth

alt if session exists AND expiredAt > current date
auth -> mi: return SSO token
else if session exists AND expiredAt <= current date
auth -> cs: POST /v01/customers/searchWithAccount
note right
{
    "filters": [
        {
            "key": "cif", 
            "value": "1AG8DC"
        },
        {
            "key": "accountTypeCode", 
            "value": "EG"
        }
    ]
}
end note
activate cs
cs --> auth: return CRN
deactivate cs
auth -> ids: POST /connect/token
note right
scope: DfsApi
grant_type: contact
client_id: Client ID
client_secret: Client Secret
access_token: ClientCredentials token
cid: 0 
sub: CRN
end note
activate ids
ids --> auth: return contact token
deactivate ids
auth -> dfs: POST /v1.0/contacts/{contactId}/authentication/tokens/renew/sso
activate dfs
dfs --> auth: return accessToken
auth -> dbauth: save session to redis
deactivate dfs
auth -> mi: return SSO token
end

auth -> cs: POST /v01/customers/searchWithAccount
note right
{
    "filters": [
        {
            "key": "cif", 
            "value": "1AG8DC"
        },
        {
            "key": "accountTypeCode", 
            "value": "EG"
        }
    ]
}
end note
activate cs
cs --> auth: return CRN
deactivate cs
auth -> ids: POST /connect/token
note right
scope: DfsApi
grant_type: contact
client_id: Client ID
client_secret: Client Secret
access_token: ClientCredentials token
cid: 0 
sub: CRN
end note
activate ids
ids --> auth: return contact token
deactivate ids

auth -> dfs: POST /v1.0/authentication/authenticate/sso
note right
AccessToken: contact token
end note
activate dfs
dfs --> auth: return SSO token
auth -> dbauth: save session to redis
auth --> mi: return SSO token

opt if contact not exists
dfs --> auth: return Result: "ContactExternalInvalid"
deactivate dfs
auth -> dfs: POST /v1.0/contacts
note right
{
    "ContactTypeId": 1,
    "Details": {
        "communicationMethods": {
            "primaryEmail": "96342901@additiv.com"
        }
    }
}
end note
activate dfs
dfs --> auth: return contactId
deactivate dfs
auth -> ids: POST /connect/token
note right
scope: DfsApi
grant_type: contact
client_id: Client ID
client_secret: Client Secret
access_token: ClientCredentials token
cid: contactId
sub: CRN/CIF
end note
activate ids
ids --> auth: return contact token
deactivate ids
auth -> dfs: POST /v1.0/contacts/{{ContactId}}/externalConnections
activate dfs
note right
"externalId": CRN
"system": "Default"
end note
auth -> dfs: POST /v1.0/contacts/{{ContactId}}/activate
auth -> dfs: POST /v1.0/authentication/authenticate/sso
note right
AccessToken: contact token
end note
dfs --> auth: return SSO token
deactivate dfs
auth -> dbauth: save session to redis
auth --> mi: return SSO token
end

deactivate auth

mi -> dfs: POST /v1.1/contacts/{contactId}/questionnaires/search
activate dfs
dfs --> mi: return risk profile detail
deactivate dfs
mi --> app: return risk profile
deactivate mi
deactivate app