@startuml mutual funds cron recurring

participant "cron-recurring" as cron
participant "ms-eod-status" as eod
collections "instructions" as instr
collections "ignoredInstructions" as ignoreds
queue "ID.JENIUS.RECURRING.INSTRUCTIONS.MUTUAL_FUNDS" as kafkaRec
participant "worker-recurring-investment" as wri
participant "ms-investment-transaction" as mit
collections "productInstructions" as prodIns
collections "inflightTransactions" as inflights
queue "ID.JENIUS.INVESTMENT.JOURNAL.REQUEST" as kafkaJournal
queue "ID.JENIUS.INVESTMENT.JOURNAL.RESPONSE" as kafkaJournalRes
participant "worker-investment-journal" as wij
queue "ID.JENIUS.INVESTMENT.TRANSACTION.REQUEST" as kafkaWms
queue "ID.JENIUS.RECURRING.RESPONSE" as kafkaRecRes
participant "worker-recurring-response" as wrr

activate cron
cron -> cron: run every day\n at 6am, 9am, and 12pm
cron -> eod: GET /eq/eod-status
alt isNightMode=true
cron -> cron: end process
end
cron -> instr: query executeDate=today\nstatus=ACTIVE\nisProcessing=false\nprocessingCode=MUTUAL_FUNDS_SUB
cron -> cron: map instructions to messages
cron -> cron: shouldUpdateStatus = if last tick in a day
cron -> kafkaRec: bulk publish instruction messages
note right
{ 
    cif: String
    recurringId: String
    processingCode: MUTUAL_FUNDS_SUB
    frequency: ONCE/DAILY/DAILY_WEEKDAYS/WEEKLY/MONTHLY
    endCondition: DATE/OCCURENCE/NONE
    startDate: Date
    endDate?: Date
    targetOccurrence?: Number
    occurrence: Number
    shouldUpdateStatus: Boolean
}
end note
activate kafkaRec
opt if publish FAILED
cron -> cron: delay for 5s and retry 3 times
end
opt if still failed and shouldUpdateStatus=true
cron -> instr: update status to PAUSED and append histories {status, executedAt}
cron -> cron: send notification
' cron -> ignoreds: insert to ignoredInstructions
end
deactivate cron
kafkaRec -> wri: consume MF sub request
deactivate kafkaRec
activate wri
wri -> instr: update isProcessing=true
wri -> mit: POST /admin/recurring-transactions
activate mit
opt if failed
wri -> instr: update isProcessing=false
opt if shouldUpdateStatus=true
wri -> instr: update status to PAUSED and append histories {status, executedAt}
wri -> wri: send notification
end
end
deactivate wri 
mit -> prodIns: query by recurringId
mit -> inflights: map data and insert inflight
note right
{ 
    source: String
    cif: String
    productCode: String
    productName: String
    productGLAccount: String
    goalCode: String
    currency: String
    amount: Number
    fee: Number
    tax: Number
    instruction: {
        recurringId: String
        frequency: ONCE/DAILY/DAILY_WEEKDAYS/WEEKLY/MONTHLY
        endCondition: DATE/OCCURENCE/NONE
        startDate: Date
        endDate?: Date
        targetOccurrence?: Number
        occurence: Number
        shouldUpdateStatus: Boolean
    }
    createdAt: Date
    modifiedAt: Date
}
end note
mit -> kafkaJournal: proceed transaction to journal posting
deactivate mit
kafkaJournalRes -> wij: Consume journal response
activate wij
wij -> kafkaWms: Publish transaction to WMS
wij -> wij: calculate next executeDate
alt if nextStatus=COMPLETED (instruction completed)
wij -> prodIns: update status, expiredAt
end
wij -> kafkaRecRes: Publish recurring response
note right 
{
    cif: String
    recurringId: String
    executedAt: Date
    status: SUCCESS/FAILED/INSUFFICIENT_BALANCE
    nextExecuteDate: Date
    nextStatus: ACTIVE/PAUSED/COMPLETED
}
end note
deactivate wij
activate kafkaRecRes
kafkaRecRes -> wrr: Consume recurring response
deactivate kafkaRecRes
activate wrr
alt if executeDate=null (instruction completed)
wrr -> instr: Delete data/update expiredAt
wrr -> wrr: send notification completed
else
wrr -> instr: Update status, executeDate, occurence, isProcessing=false\nappend histories: [{executedAt, status}]
end
deactivate wrr

@enduml